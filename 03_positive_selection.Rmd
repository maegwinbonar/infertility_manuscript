---
title: "Selection Scan Analysis"
author: "Maegwin Bonar"
date: "2025-02-12"
output:
  html_document:
    highlight: breezedark
    css:
      - "styles.css"
    toc: yes
    toc_float: no
    toc_depth: 5
editor_options:
  markdown:
    wrap: 120
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval                        = FALSE,
  echo                        = TRUE,
  cache                       = TRUE, # tidy = TRUE,
  class.output                = "bg-success"
)
knitr::opts_knit$set(
  root.dir = rprojroot::find_rstudio_root_file()
)
```

### Introduction

We generate heatmaps of the selection scan outliers defined by pFCSs along genes containing infertiliyt-assocaited loci (IAL).

We then do a hypergeometric test to determine if pFCS outliers are under- or over-represented in genes containing IAL.


### Libraries
```{r, message=FALSE}
library(tidyverse)
library(dplyr)
library(ggpubr)
library(qvalue)
library(qqman)
library(ggplot2)
library(readr)
library(data.table)
library(ggrepel)
```

### 1. Generate Heatmaps

Use get_keygenes_wwpops.R to generate dataframe containing 10kb windows of genes of interest and thier pFCSs for each population of interest. 

* Input:
  + 1) .tsv containing the following columns: chr, start, end, population, FCS, log10_FCS, gene
  + 2) .txt file of genes of interest

```{r}
#############
# HEATMAP
#############

library(forcats)

load("merged-windows2_10kb_heatmap_WWpop_FCS_0001.Rdata")

#merged_df2

merged_df_window2 <- merged_df_key_genes %>%
  rowwise() %>%
  mutate(new_coordinates = paste(chr, new_start2, new_end2, sep = ":", collapse = "-")) %>%
  ungroup()

# make NAs in log10_FCS -Inf
merged_df_window2$log10_FCS[is.na(merged_df_window2$log10_FCS)] <- 0

# color categories based on log10_FCS values
merged_df_window2$p_val <- cut(merged_df_window2$log10_FCS,
                        breaks = c(-Inf, 4, 5, Inf),
                        labels = c("<3",">4",">5"),
                        right = FALSE)

merged_df_window2$population <- fct_rev(factor(merged_df_window2$population, levels = c("EUR","EUR-Adygei", "EUR-Basque", "EUR-French", "EUR-Italian-Bergamo", "EUR-Orcadian", "EUR-Russian", "EUR-Sardinian", "EUR-Tuscan","MDE", "MDE-Bedouin", "MDE-Druze", "MDE-Mozabite", "MDE-Palestinian","CSA", 
"CSA-Balochi", "CSA-Brahui", "CSA-Burusho", "CSA-Hazara", "CSA-Kalash", "CSA-Makrani", "CSA-Pathan", "CSA-Sindhi", "CSA-Uygur","EAS", "EAS-Cambodian-Dai-Lahu", "EAS-Han-Tujia", "EAS-Japanese", "EAS-Miao-She", "EAS-Mongolian-Xibo", "EAS-NorthernHan-Tu-Yi-Naxi", "EAS-Oroqen-Daur-Hezhen", "EAS-Paiwan-Atayal", "EAS-Yakut","AMR", "AMR-Colombian-Karitiana-Surui", "AMR-Maya", "AMR-Pima", "Oceania", "Ata","Baining-Kagat","Baining-Mali","Bellona-Rennell","Kove","Lavongai-Mussau","Malaita","Mamusi","Melamela","Nailik-Notsi-Tigak","Nakanai-Mangseng","Nasioi","Santa-Cruz","Saposa","Sepik-Goroka","Tikopia","Vella-Lavella")))

labels <- c("EUR",
"EUR-Adygei", "EUR-Basque", "EUR-French", "EUR-Italian-Bergamo", "EUR-Orcadian", "EUR-Russian", "EUR-Sardinian", "EUR-Tuscan","MDE", "MDE-Bedouin", "MDE-Druze", "MDE-Mozabite", "MDE-Palestinian","CSA",
"CSA-Balochi", "CSA-Brahui", "CSA-Burusho", "CSA-Hazara", "CSA-Kalash", "CSA-Makrani", "CSA-Pathan", "CSA-Sindhi", "CSA-Uygur","EAS", "EAS-Cambodian-Dai-Lahu", "EAS-Han-Tujia", "EAS-Japanese", "EAS-Miao-She", "EAS-Mongolian-Xibo", "EAS-NorthernHan-Tu-Yi-Naxi", "EAS-Oroqen-Daur-Hezhen", "EAS-Paiwan-Atayal", "EAS-Yakut", "AMR", "AMR-Colombian-Karitiana-Surui","AMR-Pima", "AMR-Maya", "OCN",
                                                                  "OCN-Ata","OCN-Baining-Kagat","OCN-Baining-Mali","OCN-Bellona-Rennell","OCN-Kove","OCN-Lavongai-Mussau","OCN-Malaita","OCN-Mamusi","OCN-Melamela","OCN-Nailik-Notsi-Tigak","OCN-Nakanai-Mangseng","OCN-Nasioi","OCN-Santa-Cruz","OCN-Saposa","OCN-Sepik-Goroka","OCN-Tikopia","OCN-Vella-Lavella")

#separate by \n each 8 genes
merged_df_window2$gene <- gsub("((?:\\w+,\\s*){5}\\w+),", "\\1,\n", merged_df_window2$gene)

# Sort again
merged_df_window3 <- merged_df_window2 %>% 
  arrange(chr, new_start2, new_end2)

################################################

# Create a separate dataframe for organizing gene labels on the right
gene_labels_df <- merged_df_window3 %>%
  dplyr::filter(population == unique(merged_df_window3$population)[1]) %>%
  arrange(new_start2)

# HEATMAP
heatmap_plot2 <- ggplot(merged_df_window3, aes(x = population, y = forcats::fct_rev(factor(new_coordinates, levels = rev(unique(new_coordinates)))), fill = p_val)) +
  #geom_tile(color = "black", size = 0.3) +
  scale_fill_manual(
    values = c(
      "<3" = "white",
      ">4" = "#939598",#"5384E4",
      ">5" = "#424143"#"#65B8E6",  
      #">5" = "#CAE11F"#"#72E6E2"
    ),
    labels = c(
      "<3" = ">0.001",
      #">3" = "<0.001",
      ">4" = "<0.0001",
      ">5" = "<0.00001"
    )
  ) +
  scale_x_discrete(labels= rev(labels), position = "top")+
  labs(fill = expression(italic("p")[FCS])) +
  labs(x = "", y = "") +
  theme_void() +
  theme(
    #plot.title = element_text(size = 14),
    axis.text.y = element_text(hjust = 0, size = 10, vjust = 0.5),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size =8),
    axis.text.x.bottom = element_text(angle = 90, vjust = 0.5, hjust = 1),
    axis.text.x.top = element_text(angle = 90, vjust = 0.5, hjust = 1),
    axis.text.y.left = element_text(angle = 90, vjust = 0.5, hjust = 1),  # Rotate gene labels vertically
    plot.margin = margin(0.75, 0.5, 0.5, 0.5, "cm"),
    legend.box.spacing = margin(10)
  )

# Organize the gene label on the right 
heatmap_plot2 <- heatmap_plot2 +
  geom_tile(color = "black", size = 0.1) +  
  geom_text(
    data = gene_labels_df,
    aes(x = population, y = factor(new_coordinates, levels = unique(new_coordinates)), label = gene),
    #nudge_x = 32,
    nudge_x = 34,
    show.legend = FALSE,
    hjust = 0,
    vjust = 0.5, 
    size = 2.5,
    angle = 90,
  ) + coord_cartesian(clip = "off") +coord_flip()

print(heatmap_plot2)

ggsave("plots/infertility_genes_10kb_heatmap_WWpops_F_0001_new2.pdf", heatmap_plot2, width = 11, height = 10, dpi = 300, limitsize = FALSE)

## save the genes that have hits for locuszoom plots
infertility_F0001 <- unique(gene_labels_df$gene)
write.table(infertility_F0001, "infertility_genes_FCS_0.0001.tsv", quote = FALSE, col.names = FALSE, row.names = FALSE)

## save gene list per region for over/under-representation analysis
infertility_F0001_regions <- merged_df2[merged_df2$p0.0001==TRUE,]
write.table(infertility_F0001_regions, "infertility_genes_regions_FCS_0.0001.tsv", quote = FALSE, col.names = FALSE, row.names = FALSE)

```

### 2. Under-representation Analysis

We will do an over/under-representation analysis to determine if infertility genes are under-represented in genes identified as being under positive selection

x = infertility genes under selection

m = all genes under selection

n = genes not under selection

k = all infertility genes

We will do this by region, looking at OCE, ESA, CSA, and EUR separately

```{r}

# list of genes under selection by region
infert_genes_FCS <- read.table("infertility_genes_regions_FCS_0.0001.tsv", sep = " ")
colnames(infert_genes_FCS) <- c("chr", "start", "end","pop", "gene", "log10_FCS", "p_0.0001")

# list of all infertility genes
infert_genes_all <- read.table("infertilityGeneList_unique.txt")
colnames(infert_genes_all) <- c("gene", "type")

### Necessary functions
get_genes_FCS <- function(df_path){
  temp_df <- read_tsv(df_path, col_select = c(gene))
  return(temp_df)
}

# assume `genes`, `gene_set` and `universe` have the same gene ID type
ora_single = function(genes, gene_set, universe) {
    n_universe = length(universe)

    genes = intersect(genes, universe)
    gene_set = intersect(gene_set, universe)

    x = length(intersect(genes, gene_set)) # infertility genes in the gene set (under selection)
    m = length(gene_set)  # total genes in the gene set under selection
    n = n_universe - m    # total genes not in the gene set not under selection
    k = length(genes)     # total infertility genes

    phyper(x - 1, m, n, k, lower.tail = FALSE)
}

## under representation
ura_single = function(genes, gene_set, universe) {
    n_universe = length(universe)

    genes = intersect(genes, universe)
    gene_set = intersect(gene_set, universe)

    x = length(intersect(genes, gene_set)) # infertility genes in the gene set under selection
    m = length(gene_set)  # total genes in the gene set under selection
    n = n_universe - m    # total genes not in the gene set not under selection
    k = length(genes)     # total infertility genes

    phyper(x, m, n, k, lower.tail = TRUE)
}


```


#### Oceania
```{r, message=FALSE}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes under positive selection
# get all .FCS_0.0001.tsv files for all populations
path = "OceanicPops_2024_FCS"
temp <- list.files(path = path, pattern = "*0.0001.tsv", full.names = TRUE)

df_list <- lapply(temp, get_genes_FCS)

gene_set<- do.call(rbind, df_list) %>%
  separate_rows(gene, sep = ",") %>%
  distinct(gene)

### as a check, the intersection of genes and gene_set should be x
OCE_genes_FCS <- infert_genes_FCS %>%
  filter(grepl('OCE', pop))

# remove duplicates and take only gene column
x <- OCE_genes_FCS %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes, gene_set)

### universe - all genes
universe<- read.table("gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_oce <- ora_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)
ura_oce <- ura_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)

```

#### CSA
```{r, message=FALSE}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes under positive selection
# get all .FCS_0.0001.tsv files for all populations
path = "WWpop_2024_FCS"
temp <- list.files(path = path, pattern = "^CSA.*\\_0.0001.tsv$", full.names = TRUE)

df_list <- lapply(temp, get_genes_FCS)

gene_set<- do.call(rbind, df_list) %>%
  separate_rows(gene, sep = ",") %>%
  distinct(gene)

### as a check, the intersection of genes and gene_set should be x
CSA_genes_FCS <- infert_genes_FCS %>%
  filter(grepl('CSA', pop))

# remove duplicates and take only gene column
x <- CSA_genes_FCS %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes, gene_set)

### universe - all genes
universe<- read.table("gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_csa <- ora_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)
ura_csa <- ura_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)

```

#### EAS
```{r, message=FALSE}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes under positive selection
# get all .FCS_0.0001.tsv files for all populations
path = "WWpop_2024_FCS"
temp <- list.files(path = path, pattern = "^EAS.*\\_0.0001.tsv$", full.names = TRUE)

df_list <- lapply(temp, get_genes_FCS)

gene_set<- do.call(rbind, df_list) %>%
  separate_rows(gene, sep = ",") %>%
  distinct(gene)

### as a check, the intersection of genes and gene_set should be x
EAS_genes_FCS <- infert_genes_FCS %>%
  filter(grepl('EAS', pop))

# remove duplicates and take only gene column
x <- EAS_genes_FCS %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes, gene_set)

### universe - all genes
universe<- read.table("gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_eas <- ora_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)
ura_eas <- ura_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)

```

#### EUR
```{r, message=FALSE}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes under positive selection
# get all .FCS_0.0001.tsv files for all populations
path = "WWpop_2024_FCS"
temp <- list.files(path = path, pattern = "^EUR.*\\_0.0001.tsv$", full.names = TRUE)

df_list <- lapply(temp, get_genes_FCS)

gene_set<- do.call(rbind, df_list) %>%
  separate_rows(gene, sep = ",") %>%
  distinct(gene)

### as a check, the intersection of genes and gene_set should be x
EUR_genes_FCS <- infert_genes_FCS %>%
  filter(grepl('EUR', pop))

# remove duplicates and take only gene column
x <- EUR_genes_FCS %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes, gene_set)

### universe - all genes
universe<- read.table("gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_eur <- ora_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)
ura_eur <- ura_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)

```

#### AMR
```{r, message=FALSE}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes under positive selection
# get all .FCS_0.0001.tsv files for all populations
path = "WW_pops_FCS"
temp <- list.files(path = path, pattern = "^AMR.*\\_0.0001.tsv$", full.names = TRUE)

df_list <- lapply(temp, get_genes_FCS)

gene_set<- do.call(rbind, df_list) %>%
  separate_rows(gene, sep = ",") %>%
  distinct(gene)

### as a check, the intersection of genes and gene_set should be x
AMR_genes_FCS <- infert_genes_FCS %>%
  filter(grepl('AMR', pop))

# remove duplicates and take only gene column
x <- AMR_genes_FCS %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes, gene_set)

### universe - all genes
universe<- read.table("gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_amr <- ora_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)
ura_amr <- ura_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)

```

#### MDE
```{r, message=FALSE}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes under positive selection
# get all .FCS_0.0001.tsv files for all populations
path = "WWpop_2024_FCS"
temp <- list.files(path = path, pattern = "^MDE.*\\_0.0001.tsv$", full.names = TRUE)

df_list <- lapply(temp, get_genes_FCS)

gene_set<- do.call(rbind, df_list) %>%
  separate_rows(gene, sep = ",") %>%
  distinct(gene)

### as a check, the intersection of genes and gene_set should be x
MDE_genes_FCS <- infert_genes_FCS %>%
  filter(grepl('MDE', pop))

# remove duplicates and take only gene column
x <- MDE_genes_FCS %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes, gene_set)

### universe - all genes
universe<- read.table("gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_mde <- ora_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)
ura_mde <- ura_single(genes = genes$gene, gene_set = gene_set$gene, universe = universe$gene)

```


### AI deserts

Use deserts from Sankararaman et al. 2016

Intersect Sankararaman et al. 2016 files with genecode bed files
```{bash}
for f in $(ls *.bed | cut -d '.' -f 1 | uniq); do
bedtools intersect -wa -wb -a ${f}.bed -b /gpfs/gibbs/pi/tucci/mpb63/Maegwin_selection-scans/key_files/gencode.v38lift37.annotation.codingGENES_sorted.bed > ${f}_intersect_genes.bed
done
```

Genes
Sankararaman et al. 2016
Only intersected with regions from Deserts from Sankararaman et al. 2016 
 
```{bash}
for f in $(ls *deserts.bed | cut -d '.' -f 1 | uniq); do
bedtools intersect -wa -wb -a ${f}.bed -b /gpfs/gibbs/pi/tucci/mpb63/infertility_2024/infertility_analyses_2025/infertility_genes.bed > infertility_gene_intersect/${f}_intersect_infertilitygenes_2025.bed
done
```


In this case we will check whether genes associated with infertility are over-represented in genes overlapping with AI deserts

```{r}

## get the values for each parameter
# we need `genes`, `gene_set`, and `universe`

### genes - infertility genes
genes <- infert_genes_all[1]

### gene set - all genes in AI deserts NEA and DEA
gene_set_all<- read.table("/gpfs/gibbs/pi/tucci/mpb63/AI_deserts/Sankararaman_2016_DEN_NEA_deserts_intersect_genes.bed", header = FALSE)
colnames(gene_set_all) <- c("chr", "start","end","chr.y", "start.y","end.y","ensembl", "gene")

gene_set_den<- read.table("/gpfs/gibbs/pi/tucci/mpb63/AI_deserts/Sankararaman_2016_DEN_deserts_intersect_genes.bed", header = FALSE)
colnames(gene_set_den) <- c("chr", "start","end","chr.y", "start.y","end.y","ensembl", "gene")

gene_set_nea<- read.table("/gpfs/gibbs/pi/tucci/mpb63/AI_deserts/Sankararaman_2016_NEA_deserts_intersect_genes.bed", header = FALSE)
colnames(gene_set_nea) <- c("chr", "start","end","chr.y", "start.y","end.y","ensembl", "gene")

## remove duplicates
gene_set_all <- gene_set_all %>%
  distinct(gene)

gene_set_den <- gene_set_den %>%
  distinct(gene)

gene_set_nea <- gene_set_nea %>%
  distinct(gene)

### universe - all genes
universe<- read.table("/gpfs/gibbs/pi/tucci/mpb63/Maegwin_selection-scans/key_files/gencode.v38lift37.annotation.codingGENES_sorted.bed", header = FALSE)
colnames(universe) <- c("chr", "start","end","ensembl", "gene")

universe<-universe %>%
  select(gene) %>%
  distinct(gene)

#### Test
ora_ai_all <- ora_single(genes = genes$gene, gene_set = gene_set_all$gene, universe = universe$gene)
ura_ai_all <- ura_single(genes = genes$gene, gene_set = gene_set_all$gene, universe = universe$gene)

ora_ai_den <- ora_single(genes = genes$gene, gene_set = gene_set_den$gene, universe = universe$gene)
ura_ai_den <- ura_single(genes = genes$gene, gene_set = gene_set_den$gene, universe = universe$gene)

ora_ai_nea <- ora_single(genes = genes$gene, gene_set = gene_set_nea$gene, universe = universe$gene)
ura_ai_nea <- ura_single(genes = genes$gene, gene_set = gene_set_nea$gene, universe = universe$gene)

### as a check, the intersection of genes and gene_set should be x
# remove duplicates and take only gene column
ai_infert_genes <- read.table("/gpfs/gibbs/pi/tucci/mpb63/AI_deserts/infertility_gene_intersect/Sankararaman_2016_NEA_deserts_intersect_infertilitygenes.bed", header = FALSE)
colnames(ai_infert_genes) <- c("chr", "start","end","chr.y", "start.y","end.y","ensembl", "gene")

x <- ai_infert_genes %>%
  select(gene) %>%
  distinct(gene)

x_check = intersect(genes$gene, gene_set_nea$gene)

```

### Linkage Disequilibrium of lead variants

First we need to subset our vcf files to the correct population and the correct range.

We are using the range determined by locuszoom plots of 50kb to either side of the gene of interest -> found in locuszoom_genes.csv

Based on this file I have generated a csv with the gene of interest, the population for which it is under selection, and the chr, start, and end of the range we want to subset to, and the lead variant we will calculate ld based on. -> r2_selection_windows.txt

NOTE: vcftools requires you to have a header in your bed file!
```{bash}

while read gene pop chr start end var; do
echo "module load VCFtools; vcftools --gzvcf /gpfs/gibbs/pi/tucci/mpb63/Maegwin_selection-scans/vcf_files/PIBv1_chr${chr}_final_phased.SNP_only.vcf.gz --bed selection_windows/${gene}_window.bed --keep pop_files/pop_$pop.txt --recode --out r2/${pop}_$gene"
done <r2_selection_windows.txt > r2_selection_vcfs.txt

module load dSQ

dsq --job-file r2_selection_vcfs.txt --account=tucci --output log_files/r2_selection_vcfs-%A_%2a-%N.out  --mail-type ALL --job-name r2_selection_vcfs --partition day -t 1:00:00 --mem-per-cpu 8GB --cpus-per-task=1 --batch-file r2_selection_vcfs.sh

```

Next calculate r2 using plink 1.9

```{bash}

while read gene pop chr start end var; do
echo "module load PLINK/1.9b_6.21-x86_64; plink --vcf r2/${pop}_$gene.recode.vcf --allow-no-sex --snps-only --r2 inter-chr --ld-snp $var --ld-window-r2 0 --out r2/${pop}_$gene"
done <r2_selection_windows.txt > ld_calc_vcfs.txt

dsq --job-file ld_calc_vcfs.txt --account=tucci --output log_files/ld_calc_vcfs-%A_%2a-%N.out  --mail-type ALL --job-name ld_calc_vcfs --partition day -t 1:00:00 --mem-per-cpu 4GB --cpus-per-task=1 --batch-file ld_calc_vcfs.sh

```

Use locuszoom r scripts to produce plots

##### Allele frequency calculations 
```{bash}
while read chr pos; do
	echo "module load VCFtools; vcftools --gzvcf /gpfs/gibbs/pi/tucci/mpb63/Maegwin_selection-scans/vcf_files/PIBv1_chr${chr}_final_phased.SNP_only.vcf.gz --positions infertility_rsid.txt --recode --out rsid_chr${chr}"
done<infertility_rsid.txt > rsid_vcf.txt


dsq --job-file rsid_vcf.txt --account=tucci --output log_files/rsid_vcfs-%A_%2a-%N.out  --mail-type ALL --job-name rsid_vcfs --partition day -t 1:00:00 --mem-per-cpu 8GB --cpus-per-task=1 --batch-file rsid_vcfs.sh

module load BCFtools

module load tabix

for i in *.vcf; do
bgzip -c $i > $i.gz
done

for i in *.vcf.gz; do
tabix -p vcf $i
done

ls *.vcf.gz > rsid_vcf_list.txt
bcftool concat --file-list rsid_vcf_list.txt -o all_rsids

while read file pop; do
echo "module load VCFtools; vcftools --vcf all_rsids.vcf --keep ../pop_files/$file --recode --out $pop"
done<pop_files.txt > vcf_bypop.txt

dsq --job-file vcf_bypop.txt --account=tucci --output log_files/vcf_bypop-%A_%2a-%N.out  --mail-type ALL --job-name vcf_bypop --partition scavenge -t 00:30:00 --mem-per-cpu 4GB --cpus-per-task=1 --batch-file vcf_bypop.sh

while read file pop; do
echo "module load VCFtools; vcftools --vcf $pop.recode.vcf --freq --out $pop"
done<pop_files.txt > freq_bypop.txt

dsq --job-file freq_bypop.txt --account=tucci --output log_files/freq_bypop-%A_%2a-%N.out  --mail-type ALL --job-name freq_bypop --partition scavenge -t 00:30:00 --mem-per-cpu 4GB --cpus-per-task=1 --batch-file freq_bypop.sh

```

